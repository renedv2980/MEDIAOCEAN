         TITLE 'YEAR 2000 - Conversion notes'                                   
                                                                                
How DDS processes dates                                                         
-----------------------                                                         
DDS systems hold internal dates in four defined formats. It is in one           
of these formats that dates are stored in file records. The DDS routines        
DATVAL and PERVAL take free form dates that can be entered in almost any        
style, and output an internal date of type-0 format - C'YYMMDD'.                
                                                                                
After DATVAL has created a type-0 date the DDS subroutine DATCON is used        
to convert the date type-0 to any other of the standard internal date           
types 1 thru 3, and it is usually in one of these formats that a date           
will be stored in a file record. Each of these types will be discussed          
in detail below.                                                                
                                                                                
DATCON is also used to convert any of the four internal date formats to         
a displayable or printed format. There are many choices and styles of           
output dates that can be created by DATCON.                                     
                                                                                
The year 2000 problem                                                           
---------------------                                                           
The Year 2000 problem is that basically all of the DDS input validation         
routines, internal formats, and displayable output formats, assume that         
the year is a two digit number with the range 00 thru 99, and that the          
century is 19. The "19" is never entered, never stored, and never               
displayed. If the date is input as JAN01/00 (US) or 01JAN00 (UK) then           
the assumption is that we are referring to the year 1900, and not to            
the year 2000. As data in the DDS system is typically only held for             
a few years in the current past, and usually only refers to dates in            
the near future, the input of low numbered years should be assumed to           
be referring to dates in the 21st century e.g. 2000 and not 1900.               
                                                                                
If we assume that low year dates are 2000 dates and high numbered years         
are 1900 dates, then we can redefine the window that 2 digit years can          
represent. Instead of 00-99 meaning 1900 through 1999 we can say that           
00-50 refer to 2000 through 2050 and 51-99 imply 1951 through 1999. In          
this way we can support the 100 year period 1951 through 2050, which            
gives a perfectly adequate range for business oriented dates. However           
we are left with a major snag. This "windowing" technique does not              
support date order - 00 is less than 99 - so all of the 2000 dates              
will sort lower than the 1900 dates. The dates do not collate anymore,          
and file keys (where dates often appear) will go out of true date               
sequence with severe application problems.                                      
                                                                                
We need a method of upgrading our existing date formats so that                 
2000+ dates are held in a way that supports date sequence ie 2000 is            
greater than 1999 etc. We can do this by taking the year part of the            
DDS internal date formats, and redefining what the bits are so that we          
can represent 2000 plus dates as well as 1900 dates. We will see that           
it is possible to support a date period of 1900 through 2027 with all           
four types of DDS internal dates. However this does mean that some of           
the dates will contain invalid EBCDIC or packed numeric characters.             
         EJECT                                                                  
Type-0 dates - EBCDIC C'YYMMDD'                                                 
-------------------------------                                                 
The years 1900 through 1999 are supported with normal EBCDIC numbers in         
the YY field ie X'F0F0' through X'F9F9'. The decade 2000 through 2009           
is supported by using X'FA' in the first year field, so the years 2000          
through 2009 have the hex coding X'FAF0' through X'FAF9'. Note that             
as X'FA' is greater that X'F9' we get a valid collating sequence but            
we get an invalid, non-displayable, first year character in the date.           
It is possible to support collatable dates in the range 1900 through            
2059 by modifying the first year byte field, but only years 1900                
through 1999 are valid directly displayable dates.                              
                                                                                
X'FAF0' through X'FAF9' represent the years 2000 through 2009                   
X'FBF0' through X'FBF9' represent the years 2010 through 2019                   
X'FCF0' through X'FCF9' represent the years 2020 through 2029                   
X'FDF0' through X'FDF9' represent the years 2030 through 2039                   
X'FEF0' through X'FEF9' represent the years 2040 through 2049                   
X'FFF0' through X'FFF9' represent the years 2050 through 2059                   
                                                                                
Sample code to display a date in the format C'YYYYMMDD' from an encoded         
type-0 internal date is as follows :                                            
                                                                                
L1       MVC   DATEOUT(2),=C'19'   SET DEFAULT CENTURY                          
         MVC   DATEOUT+2(6),TYPE0                                               
         CLI   TYPE0,C'9'          TEST IF 2000+ FORMAT DATE                    
         BNH   L2                                                               
         MVC   DATEOUT(2),=C'20'                                                
         IC    R0,TYPE0            ADJUST 1ST YEAR BYTE FOR DISPLAY             
         SH    R0,=H'10'                                                        
         STC   R0,DATEOUT+2                                                     
L2       ...                                                                    
         ...                                                                    
TYPE0    DS    CL6                 DDS INTERNAL ENCODED TYPE-0 DATE             
DATEOUT  DS    CL8                 EBCDIC C'YYYYDMMDD' DISPLAYABLE DATE         
                                                                                
There is a new DATCON output type-20 date C'YYYYMMDD' which can be used         
to produce the same output as above. The new year 2000 version of DATCON        
will recognise a normal type-0 as well as an encoded type-0 date.               
                                                                                
         GOTO1 =V(DATCON),DMCB,(0,TYPE0),(20,DATEOUT)                           
                                                                                
Always use a DATCON call to produce type-20 style output. Do not code it        
yourself as the date formats will all change again in a few years time.         
Your own code will become invalid, whereas the DATCON call will work.           
                                                                                
We don't normally output dates in the format C'YYMMDD' on screens or in         
printed output. An exception is request programs where we sometimes             
display the start and end dates on a request card. These are held in            
type-0 format so they won't display properly for year 2000+ dates. This         
format is, however, very common in machine readable output like                 
interface tapes that we produce for other computer systems.                     
If an input date is passed to DATCON and we ask for a C'YYMMDD' type-0          
output then DATCON defaults to producing the DDS standard form of this          
date. So any year 2000+ dates will be output in non-displayable format.         
                                                                                
If DATCON is being called to output a C'YYMMDD' date to an interface            
file, then there is a new control flag that can be passed in the DATCON         
param list that will cause the output to have a normal C'YY' output             
year, with the year 2000 showing as C'00' and not X'FAF0'.If the X'20'          
bit is set on in the 1st byte of P2 (the output date type field) then           
DATCON will NOT output non-displayable dates in the DDS format.                 
                                                                                
         GOTO1 =V(DATCON),DMCB,(0,TYPE0),(X'20',OYYMMDD)                        
         ...                                                                    
OYYMMDD  DS    CL6                                                              
                                                                                
This call can be used to display a C'YYMMDD' field (from a request card         
for example) when a simple MVC OYYMMDD,TYPE0 will no longer work with           
year 2000+ dates.                                                               
         EJECT                                                                  
Type-1 dates - PWOS P'YMD'                                                      
--------------------------                                                      
The years 1900 through 1999 are supported with normal unsigned packed           
format i.e. with year X'00' through X'99'. The decade 2000 through 2009         
is supported by using X'A.' in the first year digit, so the years 2000          
through 2009 have the hex coding X'A0' through X'A9'. Note that                 
as X'A0' is greater than X'99' we get a valid collating sequence, but           
we get an invalid packed number as the first half byte is not a valid           
digit 0 through 9. It is possible to support collatable dates in the            
range 1900 through 2059 by setting the first year half byte in the              
range 0 through F.                                                              
                                                                                
X'A0' through X'A9' represent the years 2000 through 2009                       
X'B0' through X'B9' represent the years 2010 through 2019                       
X'C0' through X'C9' represent the years 2020 through 2029                       
X'D0' through X'D9' represent the years 2030 through 2039                       
X'E0' through X'E9' represent the years 2040 through 2049                       
X'F0' through X'F9' represent the years 2050 through 2059                       
                                                                                
Sample code to convert a PWOS date in type-1 format to a valid PWOS             
number containing the date is as follows :                                      
                                                                                
L1       MVI   PACKOUT,X'19'       SET DEFAULT CENTURY                          
         MVC   PACKOUT+1(3),TYPE1                                               
         CLI   TYPE1,X'99'         TEST IF YEAR GREATER THAN 99                 
         BNH   L2                                                               
         MVI   PACKOUT,X'20'       SET CENTURY FOR YEAR 2000+                   
         SR    R0,R0                                                            
         IC    R0,TYPE1                                                         
         SRDL  R0,4                                                             
         SH    R0,=H'10'           DECODE FIRST YEAR NIBBLE                     
         SLDL  R0,4                                                             
         STC   R0,PACKOUT+1                                                     
L2       ...                                                                    
         ...                                                                    
TYPE1    DS    PL3                 DDS INTERNAL ENCODED TYPE-1 DATE             
PACKOUT  DS    PL4                 PWOS X'YYYYMMDD' DATE                        
                                                                                
However it is highly recommended that the DDS subroutines be used for           
ALL date manipulations, as the routines are coded to recognise and              
correctly process the invalid packed numbers in type-1 dates. New               
features (see later) in routines DATCON and ADDAY will perform simple           
date arithmetic (such as add one to year) that should obviate the need          
for code to do date manipulations.                                              
         EJECT                                                                  
Type-2 dates - Compressed two byte dates                                        
----------------------------------------                                        
Compressed two byte dates use the first 7 bits for the year, the next           
four bits for the month, and the last 5 bits for the day. Each field            
is treated as a simple unsigned binary number, so the 7 bit year field          
can run from 0 through 127 representing the years 1900 through 2027.            
As binary numbers collate naturally, the two byte compressed date will          
extend to 2027 almost transparent to most programs.                             
                                                                                
Sample code to convert a compressed two byte format-2 date to a valid           
four byte binary date - where 1st byte is century, 2nd byte is year,            
3rd byte is month, and 4th byte is day is as follows :                          
                                                                                
L1       MVI   BINOUT,19           SET DEFAULT CENTURY                          
         SR    R0,R0                                                            
         ICM   R0,3,TYPE2                                                       
         SRDL  R0,5                SHIFT OUT DAY                                
         SRL   R1,27                                                            
         STC   R1,BINOUT+3                                                      
         SRDL  R0,4                SHIFT OUT MONTH                              
         SRL   R1,28                                                            
         STC   R1,BINOUT+2                                                      
         CH    R0,=H'100'          TEST 2000+ DATE                              
         BL    L2                                                               
         SH    R0,=H'100'                                                       
         MVI   BINOUT,20                                                        
L2       STC   R0,BINOUT+1                                                      
         ...                                                                    
TYPE2    DS    XL2                 DDS INTERNAL ENCODED TYPE-2 DATE             
BINOUT   DS    XL4                 BINARY X'YYYYMMDD' DATE                      
                                                                                
However it is highly recommended that the DDS subroutines be used for           
ALL date manipulations, as the routines are coded to recognise and              
correctly process the year convention in type-2 dates. New facilities           
in routines DATCON and ADDAY will perform simple arithmetic on dates            
(such as subtract one from month) and calls to these routines should            
be used for all date functions if possible.                                     
         EJECT                                                                  
Type-3 dates - Binary three byte dates                                          
--------------------------------------                                          
Binary three byte dates use the first byte to hold the binary year              
number, the second byte to hold the binary month number, and the                
third byte to hold the binary day number. Thus the 8 bit year field             
can run from 0 through 255 representing the years 1900 through 2155.            
As binary numbers collate naturally, the three byte binary date will            
extend to 2155 almost transparent to most programs.                             
                                                                                
Sample code to convert a binary three byte date format-3 date to a              
four byte binary date - where 1st byte is century, 2nd byte is year,            
3rd byte is month, and 4th byte is day is as follows :                          
                                                                                
L1       MVI   BINOUT,19           SET CENTURY                                  
         MVC   BINOUT+1(3),TYPE3                                                
         CLI   TYPE3,100           TEST 2000+ DATE                              
         BL    L2                                                               
         IC    R0,TYPE3                                                         
         SH    R0,=H'100'                                                       
         STC   R0,BINOUT+1                                                      
         MVI   BINOUT,20                                                        
L2       ...                                                                    
         ...                                                                    
TYPE3    DS    XL3                 DDS INTERNAL BINARY TYPE-3 DATE              
BINOUT   DS    XL4                 BINARY X'YYYYMMDD' DATE                      
                                                                                
Again programmers should not have their own code to do arithmetic               
on dates, even dates as simple to process as type-3 binary dates.               
Use one or more DDS subroutines which will insulate the programs from           
the pending date conversion when the base date will be set to 2000 and          
1900 dates will no longer exist.                                                
         EJECT                                                                  
The big file conversion to come !                                               
---------------------------------                                               
By using the above encoding techniques DDS dates can be stretched to            
support the period 1900 through 2027. This will give us collatable              
dates crossing the 1999 to 2000 boundrey easyly. The plan is to wait            
until all 20th century dates are no longer considered current, and some         
time well into the 21st century (say 2010) we will have to write and run        
file conversions on all our systems. The file conversion will involve           
removing the encoding that has been applied to all dates thus resetting         
the base date to 2000. At the same time the DDS date routines will be           
changed to represent the period 2000 through 2127.                              
                                                                                
Thus conversions to use DDS date manipulation routines will mean that no        
application code has to change when the file conversions are run. If            
date manipulating code is present, of the form of the above examples for        
each date type, then it will have to be located and changed yet again so        
that the new base date is 2000 and not 1900.                                    
         EJECT                                                                  
Defining both 20th and 21st century dates                                       
-----------------------------------------                                       
If your application has to hold pre 2000 dates (eg. date-of-birth) then         
these dates should be converted to a format that supports the century           
as well as the year. For example type-8 Julian dates are three byte PWOS        
format that support the century as well as the year. DATCON supports            
PWOS Julian as a valid input and/or output date.                                
                                                                                
International Standards Organisation (ISO)                                      
------------------------------------------                                      
International Standard ISO 8601 specifies numeric representation of             
date and time. In the US dates are coded month/day/year, and in Europe          
as day/month/year. But over 25% of the World's population (China/Japan/         
Korea/Hungary/Scandanavia/..) dates are coded as year,month,day. DDS            
now supports ISO 8601 where the date is specified in full year,month,           
and day order. See DCDATVAL, DCDATCON for further detaials.                     
                                                                                
As ISO date is formally defined as YYYY-MM-DD, a fixed format 10 chr            
field. It is also (for the sake of brevity!) allowed to be specified            
without the hyphens as YYYYMMDD.                                                
         EJECT                                                                  
DATVAL and year 2000                                                            
--------------------                                                            
DATVAL is called to validate a free form input date for a full 3 field          
date, or for short 2 field dates. See DCDATVAL for details. The output          
from DATVAL is an encoded type-0 date. DATVAL will also spot a formal           
ISO date as input as well as the normal month/day/year (US) or the              
day/month/year used in Europe.                                                  
                                                                                
DATVAL supports dates in the range 1900 through 2027 and will accept a          
full four digit year code in this range. If a year code of one or two           
digits is input,whose value lies in the range 0 thru 27 then DATVAL             
will assume a year of 2000 through 2027, and will output an encoded             
C'YYMMDD' date with the first year character as a non EBCDIC code.              
DATVAL will also set P2(1)=X'40' if a year 2000+ date is input.                 
                                                                                
If the caller sets P2(1)=X'80' then DATVAL will NOT output an encoded           
date for year 2000+ dates. You should not exercise this option unless           
you are doing something special.                                                
         EJECT                                                                  
DATCON and year 2000                                                            
--------------------                                                            
DATCON will accept as input DDS encoded dates of type 0 through 3,              
Julian dates of type 6 and 8, full C'YYYYMMDD' type-9 date, and ISO             
date C'YYYY-MM-DD' type 10 date. If a type-0 date with a year code              
in the range C'00' thru C'27' is input DATCON will assume that it               
implicitly means years 2000 through 2027. This means that the years             
1900 through 1927 are not supported as type-0 input dates. However              
output dates with types 0 through 4 will always be in DDS encoded               
format. See "Problems with years 00 and 99" below.                              
                                                                                
If you want DATCON to output a type-0 output date in a NON encoded              
form (say for an interface tape to a client with a C'YYMMDD' field              
where C'00' means 2000 implicitly) then set P2(1)=X'20'.                        
                                                                                
There are also 4 new output types that output a full 4 digit year               
code which should be used if a client interface file requires dates             
with the leading 19 or 20 preceding the year number.                            
                                                                                
Output type 20 C'YYYYMMDD'                                                      
Output type 21 C'mmmDD/YYYY (US), C'DDmmmYYYY (UK), C'DD.MM.YYYY' (GER)         
Output type 22 C'mmm/YYYY (US), C'mmmYYYY (UK), C'MM.YYYY' (GER)                
Output type 23 C'YYYY-MM-DD'                                                    
                                                                                
Note also that DATCON output types 15 and 19 produce long (4 chr) and           
short (3 chr) Julian dates that also fully support century. The short           
Julian date type-19 is a three byte PWOS date X'CYYDDD' which can be            
used to store internal dates in 3 byte fields where a full date range           
is required (for holding date-of-birth for example). If the C is 0              
the YY is assumed to be 19YY and if the C is 1 the YY is assumed to be          
20YY.                                                                           
         EJECT                                                                  
DATCON - New conversion feature                                                 
-------------------------------                                                 
There are many cases where we have a date and need to compute a new             
date which is the first or the last day of this month, the next month           
or the previous month. Most of this code already lives in application           
programs as it looks relatively simple to add one to month, and if month        
is greater than twelve, then set month to one, and add one to year, etc.        
                                                                                
However as years are now encoded it may not work adding one to year,            
especially if the date is in PWOS format. If special flags are set in           
the DATCON parameter list it will take the output date, and mofify it to        
be the first/last day of the previous,current,or next month of the input        
date. To to this we set flags in P1(1) and pass a value in P3(1).               
                                                                                
If P1(1)=X'30' (both bits X'10' and X'20') then the output date will be         
converted, as usual, to the required format specified in P2(1) but will         
adjusted to a value as requested in a date modifier passed in P3(1).            
The value of the date modifier and the returned date are as follows :           
                                                                                
0  First day of input month                                                     
1  Last day of input month                                                      
2  First day of next month after input month                                    
3  Last day of next month after input month                                     
4  First day of month before input month                                        
5  Last day of month before input month                                         
         EJECT                                                                  
PERVAL and year 2000                                                            
--------------------                                                            
PERVAL will validate a single date or a period, and allow the input of          
partial dates. If incomplete date(s) are input PERVAL makes logical             
assumptions as to the values of the missing fields and returns to               
the caller a control block containing all the values, and flags that            
say which parts of the dates have been input and those that have not.           
See DCPERVAL for a description of the routine and DDPERVALD for the             
DSECT that defines all the information returned.                                
                                                                                
PERVAL was orginally designed to validate a date period input as a              
pair of dates, but it can be called with P2(1) set to X'40' that says           
validate a single date only (i.e. don't treat as a period and inhibit           
the period computations that appear in DDPERVALD). The reason for this          
is that one call to PERVAL can replace the several calls to DATVAL and          
the call to DATCON required when the input date field can be partial            
(e.g. allowing the year not to be input). Samples of this coding                
sequence can be seen in "Problems with years 00 and 99" below.                  
                                                                                
PERVAL used to rely upon always being able to spot a year in an input           
string as it was always assumed to be a pair of integers in the range           
C'70' through C'99'. However when it was converted to support the year          
2000 and beyond, it was no longer possible to isolate the year without          
ambiguity. For example 02.97 could be assumed to be FEB97 and 02.01             
was assumed to be FEB01 (US) or 02JAN (UK) - but as 01 and 02 can be            
valid years what is the meaning of 02.01 - is it FEB01 or FEB/01 (US)           
or is it 02JAN or FEB01 (UK)?                                                   
                                                                                
There is no answer to this ambiguity. If your program calls PERVAL and          
you allow the input of partial dates (e.g. because typically the year           
is not required because we default to the current year - or we only             
expect month/year to be input) then you must set a flag in P1(1) to             
tell PERVAL how to validate a pair of integers NN.NN. If the flag is            
left unset then the default is to assume month/year. If P1(1) is set            
to X'40' then PERVAL will validate for month/day (US) or day/month (UK)         
if NN.NN or NN/NN is input.                                                     
         EJECT                                                                  
PERVAL - New conversion feature                                                 
-------------------------------                                                 
There are cases where the input is supposed to be a period that lies            
within a date period defined in a record (e.g. campaign start and end           
dates). If the year is left out of the input data then PERVAL defaults          
to the current year. If the campaign period spans a year boundry then           
the code to see if the input period lies within the campaign period             
becomes difficult and requires arithmetic on the year fields. If an             
extented PERVAL control block is passed (64 bytes - an extra 8 bytes)           
then the period for validation can be passed to PERVAL.                         
                                                                                
Setting P1=X'80' (extended output block) will cause PERVAL to look at           
the first byte of the extension area PVALIND1. This byte is tested for          
the bits PVALBVP,PVALCVP,or PVALPVP and the caller must set in PVALPERD         
a start/end date pair in either binary,compressed,or packed format.             
The input date(s) will be validated against the passed period and a flag        
will be returned X'80'=PVRINVP to show date(s) fall outside period.             
If the year is not input, perval will make two passes for the validation        
of the period. The first pass with the start period year used as the            
default, and if this fails to produce a valid period, then a second pass        
is made with the end period year as the default year.                           
         EJECT                                                                  
ADDAY and year 2000 - New conversion features                                   
---------------------------------------------                                   
ADDAY is the standard DDS subroutine that takes a type-0 input date of          
the format C'YYMMDD', and a number of days (+ or -), and returns a new          
date in type-0 format that is adjusted by the number of days passed.            
                                                                                
For the year 2000 ADDAY will (like DATCON) accept encoded type-0 dates          
as input, and will output encoded dates. But it will assume that years          
C'00' through C'27' mean 2000 through 2027, which means that 1900               
through 1927 are no longer valid inputs to ADDAY.                               
                                                                                
For similar reasons as described in "DATCON - New conversion feature"           
above the parameter list has been extended so that ADDAY can be passed          
a number of months, or a number of years, in addition to the existing           
number of days, and has the ability also to set flags in the parameter          
list that control what is to be interpreted as the last day of a month.         
For example is 970630 plus one month 970730 or 970731 as 30 is the last         
day in June, and 31 is the last day in July? The full description of            
the features of the new ADDAY can be found in DCADDAY.                          
         EJECT                                                                  
GETDAY and year 2000 - New conversion feature                                   
---------------------------------------------                                   
GETDAY is the standard DDS subroutine that takes a type-0 input date of         
the format C'YYMMDD' and returns back the day number (1-7) and the day          
of the week as a three chr language depentant string.                           
                                                                                
For the year 2000 GETDAY will (like DATCON) accept encoded type-0 dates         
as input. But it will assume that years C'00' through C'27' mean 2000           
through 2027.                                                                   
                                                                                
A new feature has been added to return the number of days in the month          
as well as the day number. If P1(1) is set to X'80' then P2(1) will we          
set to the number of days in the month. So if you have a date in type-0         
format you can call GETDAY to replace code that works with a days in a          
month table with test for leap year etc.                                        
                                                                                
So as a YR2000 conversion aid GETDAY can be used to get the number of           
days in a month without the complication of computing the day number            
by setting the DD in C'YYMMDD' to C'00' before calling GETDAY. If YYMM          
are valid then GETDAY will set days-in-month in P2(1), it will then             
find that C'00' is an invalid day and will exit with P1(1)=0. If a              
fully correct date is passed then GETDAY will compute the day in the            
week and ruturn this value in P1(1).                                            
                                                                                
         MVC   DUB(6),DATE         SET C'YYMMDD'                                
         MVC   DUB+4(2),=C'00'     SET DAY TO ZERO TO MAKE DATE INVALID         
         GOTO1 =V(GETDAY),PLIST,(X'80',DUB),(0,FULL)                            
         CLI   4(R1),0             TEST DAYS IN MONTH SET                       
         BNE   ERROR               NO - THEN YYMM IS INVALID                    
         ...                       YES 4(R1)=NUMBER OF DAYS IN MONTH            
         EJECT                                                                  
Problems with years 00 and 99                                                   
-----------------------------                                                   
You might have examples of code where the assumption that 991231 is the         
highest possible value for a date. If you are building a table of dates         
with the last entry as the maximum date, and this has a 99 for the              
year value, then the code will no longer work as 2000+ encoded dates            
will be greater than 991231. You should change your logic so that the           
high date value is greater that 2027 - use all X'FF' as the terminator.         
                                                                                
You might have code that assumes that if the year value is zero then the        
year was not input and thus can be set to a default value. This code            
will fail for two different reasons. The year zero, as in 2000, becomes         
the year 100 in our extended coding scheme. And after the big file              
conversion the year zero will become a valid year and mean 2000.                
                                                                                
DATVAL presets its six byte output area to C'000000' before locating,           
validating, and setting the individual components (year,month,day) of           
the input date. If DATVAL is called with P1(1)=1 to validate day/month          
then the year will be unchanged and thus returned as C'00'.                     
                                                                                
A subsequent call to DATVAL, and a test to see if the output year is            
zero - which used to mean "Was a year input" - will no longer work :            
                                                                                
L1       GOTO1 =V(DATVAL),DMCB,(0,INPUT),OUTPUT                                 
         OC    0(4,R1),0(R1)       TEST IF VALID YEAR/MONTH/DAY INPUT           
         BNZ   L2                                                               
         GOTO1 =V(DATVAL),DMCB,(1,INPUT),OUTPUT                                 
         OC    0(4,R1),0(R1)       TEST IF VALID MONTH/DAY INPUT                
         BZ    ERROR                                                            
L2       GOTO1 =V(DATCON),DMCB,(0,OUTPUT),(3,DUB)                               
         CLI   DUB,0               TEST IF YEAR WAS INPUT                       
         BNE   *+10                YES                                          
         MVC   DUB(1),DEFYEAR      NO SET TO DEFAULT FOR THIS ACTION            
                                                                                
The new DATCON assumes that a type-0 year of C'00' means 2000 and thus          
sets the output year to an encoded format (X'64' for binary type-3 date)        
and thus the test no longer works as the output year is not zero. Also          
when the files are converted an input year of zero will be valid and            
assumed to be 2000, and output year will be returned as zero. Again the         
assumption that if the output year from DATCON is zero, then it means           
that it was not input input, is invalid.                                        
                                                                                
Sample replacement code using PERVAL for DATVAL/DATCON calls. Note that         
as the year is allowed to be optional, we must set the flag in P1(1) to         
validate for MM.DD (US) or DD.MM (UK) if input is numeric NN.NN. Note           
also that if the year is not input PERVAL sets its value to the current         
year. If this is your required default then no extra code is required.          
                                                                                
         LA    RE,INPFLD           SET A(INPUT DATE FIELD)                      
         ST    RE,DMCB                                                          
         MVC   DMCB(1),INPFLDH+5   SET L'INPUT DATE FIELD                       
         OI    DMCB,PVINDDMM       SET VALIDATE FOR DAY/MONTH                   
         LA    RE,OUTBLK           SET A(PERVAL OUTPUT BLOCK)                   
         ST    RE,DMCB+4                                                        
         OI    DMCB+4,PVINSGLO     SET VALIDATE FOR SINGLE DATE ONLY            
*                                                                               
         GOTO1 =V(PERVAL),DMCB                                                  
         CLI   DMCB+4,PVRCONE      TEST IF VALID SINGLE DATE INPUT              
         BNE   ERROR                                                            
*                                                                               
         LA    RE,OUTBLK           POINT TO PERVAL OUTPUT BLOCK                 
         USING PERVALD,RE                                                       
         MVC   DUB(3),PVALBSTA     EXTRACT BINARY YEAR/MONTH/DAY                
         TM    PVALASSM,PVALASY    TEST IF YEAR WAS MISSING                     
         BZ    *+10                NO                                           
         MVC   DUB(1),DEFYEAR      YES SET MY DEFAULT VALUE                     
         ...                                                                    
OUTBLK   DS    XL56                PERVAL OUTPUT BLOCK                          
         ...                                                                    
       INCLUDE DDPERVALD           DSECT FOR PERVAL OUPUT BLOCK                 
